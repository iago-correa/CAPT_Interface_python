{% extends 'login/base.html' %}

{% block content %}
    <h1>Practice Session</h1>

    <button id="completeTrainingBtn" disabled>Complete Training</button>
    <hr>

    {% for audio, recording in train_set %}
        {% csrf_token %} 
        <div class="audio-block" data-audio-id="{{ audio.id }}">
            <p>
                <input type="checkbox" class="completion-checkbox" data-audio-id-chk="{{ audio.id }}" disabled style="margin-right: 5px;" />
                {{ audio.transcript }}
            </p>

            <audio id="audio_player_{{ audio.id }}"> {# Changed ID for clarity #}
                <source src="{{ audio.file.url }}" type="audio/wav">
                Your browser does not support the audio element.
            </audio>

            <button class="playReferenceBtn" data-audio-id-ref="{{ audio.id }}">Play Reference</button>

            <button class="recordBtn" data-state="idle" data-audio-id-rec="{{ audio.id }}">Start Recording</button>

            <audio id="recording_player_{{ audio.id }}">
                {% if recording and recording.recorded_audio.url %}
                    <source src="{{ recording.recorded_audio.url }}" type="audio/wav">
                {% endif %}
                Your browser does not support the audio element.
            </audio>
            <button class="playRecordingBtn" data-audio-id-playrec="{{ audio.id }}" {% if not recording %}disabled{% endif %}>Play My Latest Recording</button>
        </div>
        <hr>
    {% endfor %}

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let currentAudioIdForRecording = null; 
        const csrfToken = "{{ csrf_token }}"; 

        // Object to track listened and recorded status per audio ID for the current session
        // e.g., { "audio_id_1": { listened: false, recorded: false }, ... }
        let sessionCompletionStatus = {};

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.audio-block').forEach(block => {
                const audioId = block.dataset.audioId;
                if (audioId) {
                    sessionCompletionStatus[audioId] = { listened: false, recorded: false };
                }
            });
            updateCompleteTrainingButtonState(); // Initial state
        });

        function checkAndSetCheckbox(audioId) {
            const checkbox = document.querySelector(`.completion-checkbox[data-audio-id-chk="${audioId}"]`);
            if (checkbox && sessionCompletionStatus[audioId]) {
                if (sessionCompletionStatus[audioId].listened && sessionCompletionStatus[audioId].recorded) {
                    checkbox.checked = true;
                }
            }
        }

        function updateCompleteTrainingButtonState() {
            const completeBtn = document.getElementById('completeTrainingBtn');
            if (!completeBtn) return;

            const allTasksDone = Object.values(sessionCompletionStatus).every(status => status.listened && status.recorded);
            const hasTasks = Object.keys(sessionCompletionStatus).length > 0;

            completeBtn.disabled = !(allTasksDone && hasTasks);

            if (allTasksDone && hasTasks) {
                completeBtn.onclick = () => {
                    window.location.href = "{% url 'login:logout' %}?message=" + encodeURIComponent("トレーニングお疲れ様でした！");
                };
            } else {
                completeBtn.onclick = null; // Remove click handler if not all done
            }
        }

        // Function to log activities (listening to reference or own recording)
        async function logActivityToServer(audioSourceId, typeCode) {
            console.log("Logging activity to server:", { audioSourceId, typeCode });
            try {
                const response = await fetch("/practice/log-activity/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": csrfToken
                    },
                    body: JSON.stringify({
                        audio_source_id: audioSourceId, // Can be audio.id or recording.id
                        type: typeCode
                    })
                });
                if (!response.ok) {
                    console.error("Failed to log activity to server:", typeCode, audioSourceId, await response.text());
                }
                return response.ok;
            } catch (error) {
                console.error("Error in logActivityToServer fetch:", error);
                return false;
            }
        }

        // Event listeners for "Play Reference" buttons
        document.querySelectorAll('.playReferenceBtn').forEach(button => {
            button.onclick = async () => {
                const audioId = button.dataset.audioIdRef;
                const player = document.getElementById(`audio_player_${audioId}`);
                if (player) {
                    player.play();
                    const logged = await logActivityToServer(audioId, 'train_listen_ref');
                    if (logged && sessionCompletionStatus[audioId]) {
                        sessionCompletionStatus[audioId].listened = true;
                        console.log(`Audio ${audioId} marked as listened in session.`);
                        checkAndSetCheckbox(audioId);
                        updateCompleteTrainingButtonState();
                    }
                }
            };
        });

        // Event listeners for "Play My Latest Recording" buttons
        document.querySelectorAll('.playRecordingBtn').forEach(button => {
            button.onclick = async () => {
                const audioId = button.dataset.audioIdPlayrec; // This is the original audio's ID
                const player = document.getElementById(`recording_player_${audioId}`);
                if (player && player.currentSrc && player.src !== window.location.href) { // Check if src is valid
                    player.play();
                        const specificRecordingId = button.dataset.specificRecordingId;
                        if (specificRecordingId) {
                        await logActivityToServer(specificRecordingId, 'train_listen_own');
                        }
                } else {
                    console.warn("No recording source to play for original audio:", audioId);
                }
            };
        });


        // Simplified button disabling during recording
        function setPracticeButtonsRecordingState(isRecording, recordingButton) {
            document.querySelectorAll('.playReferenceBtn, .playRecordingBtn, .recordBtn, #completeTrainingBtn').forEach(btn => {
                if (btn !== recordingButton) { // Don't disable the button that needs to be clicked to stop
                    btn.disabled = isRecording;
                }
            });
             if(recordingButton){ // ensure the active recording button's state is managed correctly
                recordingButton.disabled = isRecording ? false : (sessionCompletionStatus[recordingButton.dataset.audioIdRec]?.recorded && sessionCompletionStatus[recordingButton.dataset.audioIdRec]?.listened);
             }
             if(!isRecording){ // after recording stops, re-evaluate all buttons
                updateCompleteTrainingButtonState();
                // Re-enable play buttons if they have sources
                 document.querySelectorAll('.playRecordingBtn').forEach(prb => {
                    const player = document.getElementById(`recording_player_${prb.dataset.audioIdPlayrec}`);
                    if (player && player.currentSrc && player.src !== window.location.href) {
                         prb.disabled = false;
                    } else {
                         prb.disabled = true;
                    }
                 });
             }
        }


        // Event listeners for "Start/Stop Recording" buttons
        document.querySelectorAll('.recordBtn').forEach(recordBtn => {
            recordBtn.onclick = async () => {
                currentAudioIdForRecording = recordBtn.dataset.audioIdRec; // Original audio.id
                const state = recordBtn.getAttribute('data-state');

                if (state === 'idle') {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];

                        setPracticeButtonsRecordingState(true, recordBtn);
                        recordBtn.textContent = 'Stop Recording';
                        recordBtn.setAttribute('data-state', 'recording');

                        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

                        mediaRecorder.onstop = async () => {
                            const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/wav' });
                            audioChunks = [];

                            const formData = new FormData();
                            formData.append('audio', blob, `train_rec_${currentAudioIdForRecording}.webm`);
                            formData.append('reference_audio', currentAudioIdForRecording);
                            formData.append('activity_type', 'train_record');

                            try {
                                const response = await fetch('/record/1/', { // POST to /record/1/ for training
                                    method: 'POST',
                                    body: formData,
                                    headers: { 'X-CSRFToken': csrfToken }
                                });
                                const data = await response.json();

                                if (response.ok && data.status === 'success' && data.recording) {
                                    console.log(`Recording for audio ${currentAudioIdForRecording} successful.`);
                                    if (sessionCompletionStatus[currentAudioIdForRecording]) {
                                        sessionCompletionStatus[currentAudioIdForRecording].recorded = true;
                                        console.log(`Audio ${currentAudioIdForRecording} marked as recorded in session.`);
                                        checkAndSetCheckbox(currentAudioIdForRecording);
                                    }

                                    const player = document.getElementById(`recording_player_${currentAudioIdForRecording}`);
                                    const source = player.querySelector('source') || document.createElement('source');
                                    source.src = data.recording.url; // URL of the new recording
                                    source.type = 'audio/wav'; // Assuming server converts to wav
                                    if (!player.hasChildNodes()) player.appendChild(source);
                                    else player.load(); // Load new source if source element already exists

                                    const playBtn = document.querySelector(`.playRecordingBtn[data-audio-id-playrec="${currentAudioIdForRecording}"]`);
                                    if (playBtn) {
                                        playBtn.disabled = false; // Enable button to play the new recording
                                        playBtn.dataset.specificRecordingId = data.recording.id; 
                                    }
                                } else {
                                    console.error("Failed to save recording for audio " + currentAudioIdForRecording + ":", data ? data.message : response.statusText);
                                    alert("Error: Could not save your recording. " + (data ? data.message : ""));
                                }
                            } catch (error) {
                                console.error("Fetch error for recording audio " + currentAudioIdForRecording + ":", error);
                                alert("Network error while saving recording. Please try again.");
                            } finally {
                                recordBtn.textContent = 'Start Recording'; // Or "Re-record"
                                recordBtn.setAttribute('data-state', 'idle');
                                setPracticeButtonsRecordingState(false, null); // Re-enable relevant buttons
                                updateCompleteTrainingButtonState(); 
                            }
                        }; // End onstop
                        mediaRecorder.start();
                    } catch (err) {
                        console.error("Could not start recording for audio " + currentAudioIdForRecording + ":", err);
                        alert("Could not start recording. Please check microphone permissions.");
                        recordBtn.textContent = 'Start Recording';
                        recordBtn.setAttribute('data-state', 'idle');
                        setPracticeButtonsRecordingState(false, null); // Re-enable buttons on error
                    }
                } else if (state === 'recording') {
                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        recordBtn.textContent = 'Stopping...';
                        recordBtn.disabled = true; // Disable while stopping
                        mediaRecorder.stop();
                    }
                }
            }; // End recordBtn.onclick
        }); // End forEach for recordBtn
    </script>
{% endblock %}